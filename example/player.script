local client = require("example.client")

go.property("local_player", true)
go.property("player_nr", 0)

local GRAVITY = -1
local MOVEMENT_SPEED = 5
local ROTATION_SPEED = 2
local JUMP_SPEED = 20

local ANIM_IDLE = "Idle"
local ANIM_WALK = "Walking_A"
local ANIM_ATTACK = "1H_Melee_Attack_Chop"
local ANIM_JUMP_START = "Jump_Start"

local EVENT_POSX = 1
local EVENT_POSY = 2
local EVENT_POSZ = 3
local EVENT_ROTX = 4
local EVENT_ROTY = 5
local EVENT_ROTZ = 6
local EVENT_FORWARD = 7
local EVENT_TURN = 8
local EVENT_EULERY = 9
local EVENT_ATTACK = 10
local EVENT_JUMP = 11

local ACTION_LEFT = hash("left")
local ACTION_RIGHT = hash("right")
local ACTION_FORWARD = hash("forward")
local ACTION_BACK = hash("back")
local ACTION_JUMP = hash("jump")
local ACTION_ATTACK = hash("attack")

local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")

local FORWARD_VECTOR = vmath.vector3(0, 0, 1)

local function play_animation(self, id, playback)
	if self.animation ~= id then
		local previous = self.animation
		local previous_playback = self.animation_playback
		self.animation = id
		self.animation_playback = playback
		model.play_anim("model#model", id, playback or go.PLAYBACK_LOOP_FORWARD, nil, function()
			self.animation = previous
			model.play_anim("model#model", previous, previous_playback or go.PLAYBACK_LOOP_FORWARD)
		end)
	end
end

local function turn(self, value)
	self.rotation = value
	if self.local_player then
		realtime.raise_event(false, value, EVENT_TURN)
	end
end

local function move(self, value)
	if value == 0 then
		play_animation(self, ANIM_IDLE)
	else
		play_animation(self, ANIM_WALK)
	end
	self.forward = value
	if self.local_player then
		realtime.raise_event(false, value, EVENT_FORWARD)
	end
end

local function attack(self)
	play_animation(self, ANIM_ATTACK, go.PLAYBACK_ONCE_FORWARD)
	if self.local_player then
		realtime.raise_event(false, 0, EVENT_ATTACK)
	end
end

local function jump(self, speed)
	self.velocity.y = speed
	self.ground_contact = false
	play_animation(self, ANIM_JUMP_START, go.PLAYBACK_ONCE_FORWARD)
	if self.local_player then
		realtime.raise_event(false, speed, EVENT_JUMP)
	end
end

local function handle_event(self, event_code, event_content)
	if event_code == EVENT_POSX then
		go.set(".", "position.x", event_content)
	elseif event_code == EVENT_POSY then
		go.set(".", "position.y", event_content)
	elseif event_code == EVENT_POSZ then
		go.set(".", "position.z", event_content)
	elseif event_code == EVENT_EULERY then
		go.set("model", "euler.y",  event_content)
	elseif event_code == EVENT_FORWARD then
		move(self, event_content)
	elseif event_code == EVENT_TURN then
		turn(self, event_content)
	elseif event_code == EVENT_ATTACK then
		attack(self)
	elseif event_code == EVENT_JUMP then
		jump(self, event_content)
	end
end


function init(self)
	-- rotation around the y-axis
	-- positive value = rotate clockwise, negative value = rotate counter clockwise, 
	self.rotation = 0

	-- movement in direction
	-- positive value = move forward, negative value = move backwards
	self.forward = 0

	self.velocity = vmath.vector3()

	-- for resolving physics collisions
	self.correction = vmath.vector3()

	-- currently played animation
	self.animation = nil

	play_animation(self, ANIM_IDLE)

	-- enabled and disable meshes to get the correct look
	-- weapons
	model.set_mesh_enabled("model#model", "1H_Sword", true)
	model.set_mesh_enabled("model#model", "1H_Sword_Offhand", false)
	model.set_mesh_enabled("model#model", "2H_Sword", false)

	-- equipment
	model.set_mesh_enabled("model#model", "Knight_Helmet", false)
	model.set_mesh_enabled("model#model", "Knight_Cape", false)

	-- different shields
	model.set_mesh_enabled("model#model", "Spike_Shield", true)
	model.set_mesh_enabled("model#model", "Round_Shield", false)
	model.set_mesh_enabled("model#model", "Rectangle_Shield", false)
	model.set_mesh_enabled("model#model", "Badge_Shield", false)

	if self.local_player then
		msg.post(".", "acquire_input_focus")
		go.set_parent("/camera", go.get_id())
		-- send position and rotation every 0.5 seconds
		-- not that rotation and forward movement is sent in
		-- on_input as soon as it happens
		self.timerh = timer.delay(0.5, true, function()
			local pos = go.get_position()
			realtime.raise_event(false, pos.x, EVENT_POSX)
			realtime.raise_event(false, pos.y, EVENT_POSY)
			realtime.raise_event(false, pos.z, EVENT_POSZ)
			realtime.raise_event(false, go.get("model", "euler.y"), EVENT_EULERY)
		end)
	else
		client.subscribe(msg.url())
	end
end

function final(self)
	if self.local_player then
		go.set_parent("/camera", nil, true)
		timer.cancel(self.timerh)
	else
		client.unsubscribe(msg.url())
	end
end

function update(self, dt)
	-- rotate model object around the y-axis
	local rot = go.get_rotation("model")
	rot = rot * vmath.quat_rotation_y(ROTATION_SPEED * -self.rotation * dt)
	go.set_rotation(rot, "model")

	-- move in direction of facing
	local dir = vmath.rotate(rot, FORWARD_VECTOR * self.forward * MOVEMENT_SPEED)

	-- set velocity along the flow based on movement direction
	-- also add gravity if in the air
	self.velocity.x = dir.x
	self.velocity.z = dir.z
	if not self.ground_contact then
		self.velocity.y = self.velocity.y + GRAVITY
	end

	-- update position
	local pos = go.get_position()
	pos = pos + self.velocity * dt
	go.set_position(pos)

	-- reset volatile variables
	self.correction = vmath.vector3()
	self.ground_contact = false
end


function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		-- https://defold.com/manuals/physics-resolving-collisions/
		if message.distance > 0 then
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
				local comp = (message.distance - message.distance * proj) * message.normal
				go.set_position(go.get_position() + comp)
				self.correction = self.correction + comp
			end
		end
		-- check for ground contact
		-- clear vertical velocity if falling
		if message.other_group == hash("floor") then
			if self.velocity.y <= 0 then
				self.velocity.y = 0
				self.ground_contact = true
			end
		end
	elseif message_id == client.EVENT then
		local id = message.id
		local data = message.data
		if data.error_code and data.error_code > 0 then
			print(data.error_string)
			return
		end
		if id == realtime.EVENT_CUSTOMEVENTACTION then
			if self.player_nr == data.player_nr then
				handle_event(self, data.event_code, data.event_content)
			end
		end
	end
end


function on_input(self, action_id, action)
	if action_id == ACTION_LEFT then
		if action.pressed then
			turn(self, -1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_RIGHT then
		if action.pressed then
			turn(self, 1)
		elseif action.released then
			turn(self, 0)
		end
	elseif action_id == ACTION_FORWARD then
		if action.pressed then
			move(self, 1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_BACK then
		if action.pressed then
			move(self, -1)
		elseif action.released then
			move(self, 0)
		end
	elseif action_id == ACTION_ATTACK then
		if action.pressed then
			attack(self)
		end
	elseif action_id == ACTION_JUMP then
		if action.pressed then
			jump(self, JUMP_SPEED)
		end
	end
end
